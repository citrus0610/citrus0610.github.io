<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 289. Game of Life - 解題紀錄</title>
    <link href="/LeetCode-289-Game-of-Life-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-289-Game-of-Life-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/game-of-life">連結</a><br>難度：Medium</p><p>給定一個只有 0 和 1 的 m x n 矩陣<br>定義周圍的格子是上、下、左、右、左上、右上、左下、右下這 8 格<br>現在要將矩陣中的每一格做轉換，轉換的規則為：</p><ol><li>若當前格子為 1，且周圍為 1 的格子少於 2 格，則當前這格變為 0</li><li>若當前格子為 1，且周圍為 1 的格子剛好有 2 個或 3 個，則當前這格變為 1</li><li>若當前格子為 1，且周圍為 1 的格子多於 3 格，則當前這格變為 0</li><li>若當前格子為 0，且周圍為 1 的格子剛好有 3 個，則當前這格變為 1</li></ol><p>題目希望只能 in-place 修改原矩陣<br>不能用額外的記憶體空間去存轉換後的元素</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>必須要在已經改了之前格子的情況下<br>還能利用這些已被改過的格子知道原本的格子是多少</p><p>對格子進行編碼</p><table><thead><tr><th>轉換情況</th><th>周圍為 1 的格子數量</th><th>編碼</th></tr></thead><tbody><tr><td>1 → 0</td><td>&lt; 2</td><td>3</td></tr><tr><td>1 → 1</td><td>&#x3D; 2 or 3</td><td>1 (不改)</td></tr><tr><td>1 → 0</td><td>&gt; 3</td><td>3</td></tr><tr><td>0 → 1</td><td>&#x3D; 3</td><td>2</td></tr></tbody></table><p>編碼如果是 3，代表原本是 1<br>編碼如果是 2，代表原本是 0<br>而 1 → 1 和 0 → 0 不用改</p><p>第一輪遍歷矩陣，將每格轉為對應的編碼<br>就能利用之前已被改過的格子知道原本是多少<br>第二輪遍歷矩陣，再將每格轉為 0 或 1</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify board in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">count_live_neighbors</span>(<span class="hljs-params">i, j</span>):<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> dx <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">for</span> dy <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> dx == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dy == <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    row = i + dx<br>                    col = j + dy<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= row &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= col &lt; n:<br>                        <span class="hljs-keyword">if</span> board[row][col] == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> board[row][col] == <span class="hljs-number">3</span>:<br>                            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> cnt<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                live_neighbors = count_live_neighbors(i, j)<br><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> live_neighbors &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> live_neighbors &gt; <span class="hljs-number">3</span>:<br>                        board[i][j] = <span class="hljs-number">3</span> <span class="hljs-comment"># 1 → 0</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> live_neighbors == <span class="hljs-number">3</span>:<br>                        board[i][j] = <span class="hljs-number">2</span> <span class="hljs-comment"># 0 → 1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">3</span>:<br>                    board[i][j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> board[i][j] == <span class="hljs-number">2</span>:<br>                    board[i][j] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_live_neighbors</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span>&amp; m, <span class="hljs-type">int</span>&amp; n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dx = <span class="hljs-number">-1</span>; dx &lt;= <span class="hljs-number">1</span>; dx++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dy = <span class="hljs-number">-1</span>; dy &lt;= <span class="hljs-number">1</span>; dy++) &#123;<br>                <span class="hljs-keyword">if</span> (dx == <span class="hljs-number">0</span> &amp;&amp; dy == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> row = i + dx, col = j + dy;<br>                <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n) &#123;<br>                    <span class="hljs-type">int</span> val = board[row][col];<br>                    <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span> || val == <span class="hljs-number">3</span>)<br>                        cnt++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gameOfLife</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>(), n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> live_neighbors = <span class="hljs-built_in">count_live_neighbors</span>(i, j, board, m, n);<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (live_neighbors &lt; <span class="hljs-number">2</span> || live_neighbors &gt; <span class="hljs-number">3</span>)<br>                        board[i][j] = <span class="hljs-number">3</span>; <span class="hljs-comment">// 1 → 0</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (live_neighbors == <span class="hljs-number">3</span>)<br>                        board[i][j] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 0 → 1</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">3</span>)<br>                    board[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">2</span>)<br>                    board[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Matrix</tag>
      
      <tag>Simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 32. Longest Valid Parentheses - 解題紀錄</title>
    <link href="/LeetCode-32-Longest-Valid-Parentheses-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-32-Longest-Valid-Parentheses-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/longest-valid-parentheses">連結</a><br>難度：Hard</p><p>給定只含有左括號和右括號的字串<br>求最長的有正確括起來的 substring 的長度</p><h2 id="解法：stack"><a href="#解法：stack" class="headerlink" title="解法：stack"></a>解法：stack</h2><p>和<a href="https://citrus0610.github.io/LeetCode-20-Valid-Parentheses-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84">這題</a>差不多<br>只是變成求最大的長度<br>既然求長度，就要將 index 放入 stack<br>我們改成不放字元，只放入 index<br>而這個 index 會是上一個沒有辦法對應的括號的 index<br>當括號能對應時<br>就可透過當前遍歷的 index 和 stack 最上方的 index 計算出來<br>而一開始 stack 要先放入 -1，才能正確計算</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestValidParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = [-<span class="hljs-number">1</span>]<br>        max_len = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> char == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(i)<br>            <span class="hljs-keyword">else</span>:<br>                stack.pop()<br>                <span class="hljs-keyword">if</span> stack:<br>                    cur_len = i - stack[-<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">if</span> cur_len &gt; max_len:<br>                        max_len = cur_len<br>                <span class="hljs-keyword">else</span>:<br>                    stack.append(i)<br>        <span class="hljs-keyword">return</span> max_len<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br><br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>, cur_len;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                st.<span class="hljs-built_in">push</span>(i);<br>            <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())<br>                    st.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    cur_len = i - st.<span class="hljs-built_in">top</span>();<br>                    <span class="hljs-keyword">if</span> (cur_len &gt; max_len)<br>                        max_len = cur_len;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>String</tag>
      
      <tag>Stack</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 20. Valid Parentheses - 解題紀錄</title>
    <link href="/LeetCode-20-Valid-Parentheses-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-20-Valid-Parentheses-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/valid-parentheses">連結</a><br>難度：Easy</p><p>給定只含有括號字元 <code>()&#123;&#125;[]</code> 的字串<br>判斷是否有正確括起來</p><h2 id="解法：stack"><a href="#解法：stack" class="headerlink" title="解法：stack"></a>解法：stack</h2><p>用一個 stack<br>遍歷字串每個字元<br>當字元是左括號時，放入 stack<br>如果是右括號，判斷 stack 最上面的字元是否為對應的左括號<br>如果是的話，拿掉 stack 最上面的字元<br>如果不是，或者 stack 為空的話，代表無法對應</p><p>遍歷完所有字元後，回傳 stack 是否為空<br>若不為空代表有括號無法對應</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        stack = []<br>        pairs = &#123;<span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>&#125;<br><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> pairs.values():<br>                stack.append(char)<br>            <span class="hljs-keyword">elif</span> char <span class="hljs-keyword">in</span> pairs:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack[-<span class="hljs-number">1</span>] != pairs[char]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                stack.pop()<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; pairs = &#123;<br>            &#123;<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (pairs.<span class="hljs-built_in">count</span>(c)) &#123;<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != pairs[c])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span><br>                st.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>String</tag>
      
      <tag>Stack</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1047. Remove All Adjacent Duplicates In String - 解題紀錄</title>
    <link href="/LeetCode-1047-Remove-All-Adjacent-Duplicates-In-String-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-1047-Remove-All-Adjacent-Duplicates-In-String-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string">連結</a><br>難度：Easy</p><p>每次將字串中相鄰的相同字元刪除掉<br>一直做到底，回傳最後結果<br>而題目說不管怎麼做，答案都會是唯一的</p><h2 id="解法：stack"><a href="#解法：stack" class="headerlink" title="解法：stack"></a>解法：stack</h2><p>用一個 stack<br>遍歷字串中每一個字元時<br>判斷字元是否和 stack 最上面的字元相同<br>若不相同，將字元放入 stack<br>若相同，將 stack 最上面的字元拿掉<br>而最後 stack 裡剩下的字元組成的字串就是答案</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        stack = []<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">1</span>] == char:<br>                stack.pop()<br>            <span class="hljs-keyword">else</span>:<br>                stack.append(char)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(stack)<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string stack;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; stack.<span class="hljs-built_in">back</span>() == c)<br>                stack.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">else</span><br>                stack.<span class="hljs-built_in">push_back</span>(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>String</tag>
      
      <tag>Stack</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 102. Binary Tree Level Order Traversal - 解題紀錄</title>
    <link href="/LeetCode-102-Binary-Tree-Level-Order-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-102-Binary-Tree-Level-Order-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal">連結</a><br>難度：Medium</p><p>回傳 binary tree 裡每一層的 node</p><h2 id="解法：BFS"><a href="#解法：BFS" class="headerlink" title="解法：BFS"></a>解法：BFS</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        ans = []<br>        <span class="hljs-keyword">if</span> root:<br>            q = deque([root])<br>            <span class="hljs-keyword">while</span> q:<br>                level_nodes = []<br>                <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                    node = q.popleft()<br>                    level_nodes.append(node.val)<br>                    <span class="hljs-keyword">if</span> node.left:<br>                        q.append(node.left)<br>                    <span class="hljs-keyword">if</span> node.right:<br>                        q.append(node.right)<br>                ans.append(level_nodes)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> level_size;<br>        TreeNode* node;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level_nodes;<br>            level_size = q.<span class="hljs-built_in">size</span>();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level_size; i++) &#123;<br>                node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level_nodes.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br><br>                <span class="hljs-keyword">if</span> (node-&gt;left)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(level_nodes);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 145. Binary Tree Postorder Traversal - 解題紀錄</title>
    <link href="/LeetCode-145-Binary-Tree-Postorder-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-145-Binary-Tree-Postorder-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal">連結</a><br>難度：Easy</p><p>binary tree 做後序遍歷 (postorder traversal)：左、右、中</p><h2 id="解法1：遞迴"><a href="#解法1：遞迴" class="headerlink" title="解法1：遞迴"></a>解法1：遞迴</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        ans = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder_traverse</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br>            postorder_traverse(node.left)<br>            postorder_traverse(node.right)<br>            ans.append(node.val)<br><br>        postorder_traverse(root)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder_traverse</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">postorder_traverse</span>(node-&gt;left, ans);<br>        <span class="hljs-built_in">postorder_traverse</span>(node-&gt;right, ans);<br>        ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">postorder_traverse</span>(root, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法2：stack-迭代"><a href="#解法2：stack-迭代" class="headerlink" title="解法2：stack 迭代"></a>解法2：stack 迭代</h2><h3 id="寫法1"><a href="#寫法1" class="headerlink" title="寫法1"></a>寫法1</h3><p>每個 node 第一次被處理時，先不放進答案裡<br>而是維持放在 stack 裡並標記為已走過<br>然後將右邊的 node 與左邊的 node 依序放入 stack<br>這樣左邊的 node 才會先被處理 (可參考<a href="https://citrus0610.github.io/LeetCode-144-Binary-Tree-Preorder-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84">這題</a>的做法)</p><p>當節點第二次被處理時 (visited 為 True)<br>代表它的左邊 node 和右邊 node 都已經處理完了<br>此時再放進答案裡</p><p>有些網路上的解法會暫時把左邊或右邊的 node 設為 None<br>但這樣會破壞到 tree 原本的結構<br>如果遍歷完之後，tree 本身還會用到的話<br>裡面結構就會是錯的，因此這種做法比較不好<br>詳細可看底下附的參考文章</p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        stack = [(root, <span class="hljs-literal">False</span>)]<br>        ans = []<br><br>        <span class="hljs-keyword">while</span> stack:<br>            node, visited = stack[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                stack.pop()<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-keyword">if</span> visited: <span class="hljs-comment"># 第二次走到時，代表這個 node 的 left 和 right 都處理完了</span><br>                ans.append(node.val)<br>                stack.pop()<br>            <span class="hljs-keyword">else</span>:<br>                stack[-<span class="hljs-number">1</span>] = (node, <span class="hljs-literal">True</span>) <span class="hljs-comment"># 第一次走到時，先標記為已走過，之後再處理</span><br>                stack.append((node.right, <span class="hljs-literal">False</span>))<br>                stack.append((node.left, <span class="hljs-literal">False</span>))<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-type">bool</span>&gt;&gt; st;<br>        st.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-literal">false</span>&#125;);<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>        pair&lt;TreeNode*, <span class="hljs-type">bool</span>&gt; top;<br>        TreeNode* node;<br>        <span class="hljs-type">bool</span> visited;<br><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            top = st.<span class="hljs-built_in">top</span>();<br>            node = top.first;<br>            visited = top.second;<br>            <span class="hljs-keyword">if</span> (!node) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (visited) &#123; <span class="hljs-comment">// 第二次走到時，代表這個 node 的 left 和 right 都處理完了</span><br>                ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">top</span>().second = <span class="hljs-literal">true</span>; <span class="hljs-comment">//  第一次走到時，先標記為已走過，之後再處理</span><br>                st.<span class="hljs-built_in">push</span>(&#123;node-&gt;right, <span class="hljs-literal">false</span>&#125;);<br>                st.<span class="hljs-built_in">push</span>(&#123;node-&gt;left, <span class="hljs-literal">false</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="寫法2"><a href="#寫法2" class="headerlink" title="寫法2"></a>寫法2</h3><p>優化成不需要在 stack 裡面多存 True&#x2F;False<br>改成只用一個變數 <code>last_visited</code> 紀錄<br>由於當我們返回 node 的時候<br>我們不知道它是從左邊回來還是從右邊回來<br>因此這個變數會用來紀錄上一次走完的 node<br>這樣才能判斷右邊 node 是否已經走完<br>如果是，才加進答案裡</p><h3 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        ans = []<br>        stack = []<br>        last_visited = <span class="hljs-literal">None</span><br>        cur = root<br><br>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-keyword">if</span> cur:<br>                stack.append(cur)<br>                cur = cur.left<br>            <span class="hljs-keyword">else</span>:<br>                node = stack[-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">and</span> last_visited != node.right:<br>                    <span class="hljs-comment"># 如果 right 存在且沒處理過，就往右走</span><br>                    cur = node.right<br>                <span class="hljs-keyword">else</span>: <span class="hljs-comment"># left 和 right 都處理完了</span><br>                    ans.append(node.val)<br>                    last_visited = stack.pop()<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode *last_visited = <span class="hljs-literal">nullptr</span>, *cur = root, *node;<br><br>        <span class="hljs-keyword">while</span> (cur || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = st.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">// 如果 right 存在且沒處理過，就往右走</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right &amp;&amp; last_visited != node-&gt;right)<br>                    cur = node-&gt;right;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// left 和 right 都處理完了</span><br>                    ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                    last_visited = node;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://www.shubo.io/iterative-binary-tree-traversal/">三種 Iterative Binary Tree Traversal 的方法 (Inorder, Preorder, Postorder)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Stack</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 94. Binary Tree Inorder Traversal - 解題紀錄</title>
    <link href="/LeetCode-94-Binary-Tree-Inorder-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-94-Binary-Tree-Inorder-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal">連結</a><br>難度：Easy</p><p>binary tree 做中序遍歷 (inorder traversal)：左、中、右</p><h2 id="解法1：遞迴"><a href="#解法1：遞迴" class="headerlink" title="解法1：遞迴"></a>解法1：遞迴</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        ans = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorder_traverse</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br>            inorder_traverse(node.left)<br>            ans.append(node.val)<br>            inorder_traverse(node.right)<br><br>        inorder_traverse(root)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder_traverse</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder_traverse</span>(node-&gt;left, ans);<br>        ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-built_in">inorder_traverse</span>(node-&gt;right, ans);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">inorder_traverse</span>(root, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法2：stack-迭代"><a href="#解法2：stack-迭代" class="headerlink" title="解法2：stack 迭代"></a>解法2：stack 迭代</h2><p>每次判斷當前 node 如果不是 None 就放進 stack 並且往左走<br>如果是 None，代表左邊的 node 已經走完<br>此時拿出 stack 最上面的 node，放進答案裡<br>接著往右走</p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        stack = []<br>        ans = []<br>        node = root<br><br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-keyword">if</span> node:<br>                stack.append(node)<br>                node = node.left<br>            <span class="hljs-keyword">else</span>:<br>                node = stack.pop()<br>                ans.append(node.val)<br>                node = node.right<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* node = root;<br><br>        <span class="hljs-keyword">while</span> (node || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                st.<span class="hljs-built_in">push</span>(node);<br>                node = node-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                node = node-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://www.shubo.io/iterative-binary-tree-traversal/">三種 Iterative Binary Tree Traversal 的方法 (Inorder, Preorder, Postorder)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Stack</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 144. Binary Tree Preorder Traversal - 解題紀錄</title>
    <link href="/LeetCode-144-Binary-Tree-Preorder-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-144-Binary-Tree-Preorder-Traversal-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal">連結</a><br>難度：Easy</p><p>binary tree 做前序遍歷 (preorder traversal)：中、左、右</p><h2 id="解法1：遞迴"><a href="#解法1：遞迴" class="headerlink" title="解法1：遞迴"></a>解法1：遞迴</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        ans = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder_traverse</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br>            ans.append(node.val)<br>            preorder_traverse(node.left)<br>            preorder_traverse(node.right)<br><br>        preorder_traverse(root)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder_traverse</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node)<br>            <span class="hljs-keyword">return</span>;<br>        ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-built_in">preorder_traverse</span>(node-&gt;left, ans);<br>        <span class="hljs-built_in">preorder_traverse</span>(node-&gt;right, ans);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">preorder_traverse</span>(root, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法2：stack-迭代"><a href="#解法2：stack-迭代" class="headerlink" title="解法2：stack 迭代"></a>解法2：stack 迭代</h2><p>每次從 stack 裡面拿出中間的 node，放進答案裡<br>由於要讓左邊的 node 先拿出來<br>因此要先將右邊的 node 放上去<br>這樣左邊的 node 才會在上面</p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br><br>        stack = [root]<br>        ans = []<br><br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            ans.append(node.val)<br>            <span class="hljs-keyword">if</span> node.right:<br>                stack.append(node.right)<br>            <span class="hljs-keyword">if</span> node.left:<br>                stack.append(node.left)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br><br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        TreeNode* node;<br><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br><br>            <span class="hljs-keyword">if</span> (node-&gt;right)<br>                st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span> (node-&gt;left)<br>                st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://www.shubo.io/iterative-binary-tree-traversal/">三種 Iterative Binary Tree Traversal 的方法 (Inorder, Preorder, Postorder)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Stack</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 25. Reverse Nodes in k-Group - 解題紀錄</title>
    <link href="/LeetCode-25-Reverse-Nodes-in-k-Group-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-25-Reverse-Nodes-in-k-Group-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group">連結</a><br>難度：Hard</p><p>將 linked list 裡每 k 個 node 為一組進行反轉<br>剩下不到 k 個的部份不用反轉</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>反轉 k 個 node 的部份<br>直接使用<a href="https://citrus0610.github.io/LeetCode-92-Reverse-Linked-List-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84">這題</a>已經寫好的 code<br>在反轉 k 個 node 前，會先判斷有沒有到 k 個<br>要注意的是，反轉 k 個 node 完要回傳反轉後的最後一個 node<br>不然會錯，因為 node 已經被改過了</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse_next_k_nodes</span>(<span class="hljs-params">left_pre_node: <span class="hljs-type">Optional</span>[ListNode]</span>):<br>            node = left_pre_node.<span class="hljs-built_in">next</span><br>            pre_node = left_pre_node<br>            cnt = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> cnt &lt;= k:<br>                next_node = node.<span class="hljs-built_in">next</span><br>                node.<span class="hljs-built_in">next</span> = pre_node<br>                pre_node = node<br>                node = next_node <span class="hljs-comment"># 遍歷完後，node 會是剩餘的第一個 node</span><br>                cnt += <span class="hljs-number">1</span><br><br>            tail = left_pre_node.<span class="hljs-built_in">next</span><br>            left_pre_node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = node <span class="hljs-comment"># 將反轉後的最後一個 node 接回剩餘的 node</span><br>            left_pre_node.<span class="hljs-built_in">next</span> = pre_node <span class="hljs-comment"># 指向反轉後的第一個 node</span><br>            <span class="hljs-keyword">return</span> tail <span class="hljs-comment"># 回傳反轉後的最後一個 node</span><br><br>        dummy = ListNode(<span class="hljs-built_in">next</span>=head)<br>        left_pre_node = dummy<br>        node = dummy.<span class="hljs-built_in">next</span><br>        cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> node:<br>            <span class="hljs-keyword">if</span> cnt == k:<br>                left_pre_node = reverse_next_k_nodes(left_pre_node)<br>                node = left_pre_node.<span class="hljs-built_in">next</span><br>                cnt = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                node = node.<span class="hljs-built_in">next</span><br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse_next_k_nodes</span><span class="hljs-params">(ListNode* left_pre_node, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *node = left_pre_node-&gt;next, *pre_node = left_pre_node, *next_node;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (cnt &lt;= k) &#123;<br>            next_node = node-&gt;next;<br>            node-&gt;next = pre_node;<br>            pre_node = node;<br>            node = next_node;<br>            cnt++;<br>        &#125;<br><br>        ListNode* tail = left_pre_node-&gt;next;<br>        left_pre_node-&gt;next-&gt;next = node;<br>        left_pre_node-&gt;next = pre_node;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>, head)</span></span>;<br>        ListNode *left_pre_node = &amp;dummy, *node = dummy.next;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (cnt == k) &#123;<br>                left_pre_node = <span class="hljs-built_in">reverse_next_k_nodes</span>(left_pre_node, k);<br>                node = left_pre_node-&gt;next;<br>                cnt = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node-&gt;next;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 92. Reverse Linked List II - 解題紀錄</title>
    <link href="/LeetCode-92-Reverse-Linked-List-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-92-Reverse-Linked-List-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/reverse-linked-list-ii">連結</a><br>難度：Medium</p><p>承<a href="https://leetcode.com/problems/reverse-linked-list">上一題</a><br>反轉 linked list 裡，位置在 left 到 right 之間的 node</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>先找 left 的前一個 node<br>再用<a href="https://citrus0610.github.io/LeetCode-206-Reverse-Linked-List-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84">上一題的方式</a>反轉 left 到 right 之間的 node<br>最後把反轉後的最後一個 node 和第一個 node 接回去</p><p>為了避免需要處理存取 <code>.next</code> 時會取到 <code>None</code> 的情況<br>使用一個 <code>dummy</code>，讓它的 next 指向 head<br>最後再回傳 <code>dummy.next</code></p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-built_in">next</span>=head)<br>        left_pre_node = dummy <span class="hljs-comment"># 找 left 的前一個 node</span><br>        cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> cnt &lt;= left - <span class="hljs-number">1</span>:<br>            left_pre_node = left_pre_node.<span class="hljs-built_in">next</span><br>            cnt += <span class="hljs-number">1</span><br><br>        node = left_pre_node.<span class="hljs-built_in">next</span><br>        pre_node = left_pre_node<br>        cnt = left<br>        <span class="hljs-keyword">while</span> cnt &lt;= right:<br>            next_node = node.<span class="hljs-built_in">next</span><br>            node.<span class="hljs-built_in">next</span> = pre_node<br>            pre_node = node<br>            node = next_node <span class="hljs-comment"># 遍歷完後，node 會是剩餘的第一個 node</span><br>            cnt += <span class="hljs-number">1</span><br><br>        left_pre_node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = node <span class="hljs-comment"># 將反轉後的最後一個 node 接回剩餘的 node</span><br>        left_pre_node.<span class="hljs-built_in">next</span> = pre_node <span class="hljs-comment"># 指向反轉後的第一個 node</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>, head)</span></span>;<br>        ListNode* left_pre_node = &amp;dummy; <span class="hljs-comment">// 找 left 的前一個 node</span><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cnt &lt;= left - <span class="hljs-number">1</span>) &#123;<br>            left_pre_node = left_pre_node-&gt;next;<br>            cnt++;<br>        &#125;<br><br>        ListNode *node = left_pre_node-&gt;next, *pre_node = left_pre_node, *next_node;<br>        cnt = left;<br>        <span class="hljs-keyword">while</span> (cnt &lt;= right) &#123;<br>            next_node = node-&gt;next;<br>            node-&gt;next = pre_node;<br>            pre_node = node;<br>            node = next_node; <span class="hljs-comment">// 遍歷完後，node 會是剩餘的第一個 node</span><br>            cnt++;<br>        &#125;<br><br>        left_pre_node-&gt;next-&gt;next = node; <span class="hljs-comment">// 將反轉後的最後一個 node 接回剩餘的 node</span><br>        left_pre_node-&gt;next = pre_node; <span class="hljs-comment">// 指向反轉後的第一個 node</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 206. Reverse Linked List - 解題紀錄</title>
    <link href="/LeetCode-206-Reverse-Linked-List-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-206-Reverse-Linked-List-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/reverse-linked-list">連結</a><br>難度：Easy</p><p>反轉 linked list，並回傳新的 head</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>遍歷所有 node<br>每次把 node 的 next 指向上一個 node</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        node = head<br>        pre_node = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> node:<br>            next_node = node.<span class="hljs-built_in">next</span><br>            node.<span class="hljs-built_in">next</span> = pre_node<br>            pre_node = node<br>            node = next_node<br>        <span class="hljs-keyword">return</span> pre_node<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *node = head, *pre_node = <span class="hljs-literal">nullptr</span>, *next_node;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            next_node = node-&gt;next;<br>            node-&gt;next = pre_node;<br>            pre_node = node;<br>            node = next_node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre_node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 367. Valid Perfect Square - 解題紀錄</title>
    <link href="/LeetCode-367-Valid-Perfect-Square-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-367-Valid-Perfect-Square-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/valid-perfect-square">連結</a><br>難度：Easy</p><p>判斷給定的正整數是否為完全平方數<br>跟<a href="https://leetcode.com/problems/sqrtx">這題</a>幾乎一樣<br>直接用<a href="https://citrus0610.github.io/LeetCode-69-Sqrt-x-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/">解題文章</a>的方法</p><h2 id="解法1：暴力法"><a href="#解法1：暴力法" class="headerlink" title="解法1：暴力法"></a>解法1：暴力法</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPerfectSquare</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i * i == num:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> i * i &gt; num:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>Runtime：6ms - Beats 10.17%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> square = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((square = (<span class="hljs-type">long</span>)i * i) &lt;= num) &#123;<br>            <span class="hljs-keyword">if</span> (square == num)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法2：二分搜-binary-search"><a href="#解法2：二分搜-binary-search" class="headerlink" title="解法2：二分搜 (binary search)"></a>解法2：二分搜 (binary search)</h2><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPerfectSquare</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        left, right = <span class="hljs-number">0</span>, num<br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            square = mid * mid<br>            <span class="hljs-keyword">if</span> square &gt; num:<br>                right = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> square &lt; num:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = num;<br>        <span class="hljs-type">long</span> mid, square;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            square = mid * mid;<br>            <span class="hljs-keyword">if</span> (square &gt; num)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (square &lt; num)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法3：牛頓法"><a href="#解法3：牛頓法" class="headerlink" title="解法3：牛頓法"></a>解法3：牛頓法</h2><p>求出根號 num 的整數部分後<br>判斷它的平方是否和原數相同</p><h3 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPerfectSquare</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        x = num<br>        <span class="hljs-keyword">while</span> x * x &gt; num:<br>            x = (x + num / x) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> x * x == num<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">long</span> x = num;<br>        <span class="hljs-keyword">while</span> (x * x &gt; num)<br>            x = (x + num / x) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)x * (<span class="hljs-type">int</span>)x == num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://darktiantian.github.io/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math/">LeetCode算法题整理（数学篇）Math</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Math</tag>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 221. Maximal Square - 解題紀錄</title>
    <link href="/LeetCode-221-Maximal-Square-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-221-Maximal-Square-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/maximal-square">連結</a></p><p>給定一個 m x n 的矩陣，裡面的值只有 0 和 1<br>找出含有 1 的最大的正方形的面積</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>如果用暴力法<br>若 k 代表 m 和 n 比較小的那個<br>依序由左到右、由上到下掃過 1x1，2x2，3x3，…，kxk 的正方形<br>每次判斷正方形裡的值是否全為 1<br>時間複雜度：</p><div style="font-size: 1.3em">$O\left(mn \cdot \sum_{i=1}^{k} i^2 \right)= O\left(mn \cdot \frac{k(k+1)(2k+1)}{6} \right)= O\left(mn \cdot k^3 \right)$</div><p>太大，這樣做的話會超時<br>就不貼出來了</p><h2 id="解法：DP"><a href="#解法：DP" class="headerlink" title="解法：DP"></a>解法：DP</h2><h3 id="寫法1：二維-DP"><a href="#寫法1：二維-DP" class="headerlink" title="寫法1：二維 DP"></a>寫法1：二維 DP</h3><p><code>dp[i][j]</code> 代表到目前為止，從左上到右下含有 <code>matrix[i][j]</code> 這個位置的最大正方形邊長<br>若 <code>matrix[i][j] == 0</code>，<code>dp[i][j]</code> 為 0<br>若 <code>matrix[i][j] == 1</code><br>則 <code>dp[i][j]</code> 為左邊、上面、左上的最小值 + 1<br>因為這三格要同時相等，加入 <code>dp[i][j]</code> 後才會構成更大的正方形<br>也就是 <code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code><br>過程中紀錄最大值即可</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximalSquare</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        max_len = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>                max_len = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">if</span> matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>                max_len = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> dp[i][j] &gt; max_len:<br>                        max_len = dp[i][j]<br><br>        <span class="hljs-keyword">return</span> max_len * max_len<br></code></pre></td></tr></table></figure><p>Runtime：86ms - Beats 97.73%</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>                max_len = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                max_len = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (dp[i][j] &gt; max_len)<br>                        max_len = dp[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len * max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：3ms - Beats 90.68%</p><h3 id="寫法2：2-個一維-DP"><a href="#寫法2：2-個一維-DP" class="headerlink" title="寫法2：2 個一維 DP"></a>寫法2：2 個一維 DP</h3><p>將 dp 優化為 2 個一維空間，分別為 prev 和 dp<br>dp 用來計算當前 row 的結果<br>prev 用來存上一個 row 的 dp<br>變為 <code>dp[j] = min(prev[j], dp[j-1], prev[j-1]) + 1</code></p><h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximalSquare</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        prev = [<span class="hljs-number">0</span>] * n<br>        max_len = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            dp = [<span class="hljs-number">0</span>] * n<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                        dp[j] = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        dp[j] = <span class="hljs-built_in">min</span>(prev[j], dp[j-<span class="hljs-number">1</span>], prev[j-<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> dp[j] &gt; max_len:<br>                        max_len = dp[j]<br>            prev = dp<br>        <span class="hljs-keyword">return</span> max_len * max_len<br></code></pre></td></tr></table></figure><p>Runtime：70ms - Beats 98.63%</p><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prev</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>                        dp[j] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span><br>                        dp[j] = <span class="hljs-built_in">min</span>(&#123;prev[j], dp[j<span class="hljs-number">-1</span>], prev[j<span class="hljs-number">-1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (dp[j] &gt; max_len)<br>                        max_len = dp[j];<br>                &#125;<br>            &#125;<br>            prev = dp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len * max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：3ms - Beats 90.68%</p><h3 id="寫法3：1-個一維-DP"><a href="#寫法3：1-個一維-DP" class="headerlink" title="寫法3：1 個一維 DP"></a>寫法3：1 個一維 DP</h3><p>還能更進一步優化成 prev 只用一個變數存，省掉一維空間</p><h5 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximalSquare</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        dp = [<span class="hljs-number">0</span>] * n<br>        prev = <span class="hljs-number">0</span>  <span class="hljs-comment"># 左上角，即上一輪的 dp[j-1]</span><br>        max_len = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                tmp = dp[j]<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                        dp[j] = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j-<span class="hljs-number">1</span>], prev) + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> dp[j] &gt; max_len:<br>                        max_len = dp[j]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[j] = <span class="hljs-number">0</span><br>                prev = tmp  <span class="hljs-comment"># 更新 prev，變成下一輪的左上角</span><br>        <span class="hljs-keyword">return</span> max_len * max_len<br></code></pre></td></tr></table></figure><p>Runtime：63ms - Beats 98.75%</p><h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>, prev = <span class="hljs-number">0</span>, tmp; <span class="hljs-comment">// prev 為左上角，即上一輪的 dp[j-1]</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                tmp = dp[j]; <span class="hljs-comment">// 暫存原本的 dp[j]，下一輪會變成左上角</span><br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>                        dp[j] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span><br>                        dp[j] = <span class="hljs-built_in">min</span>(&#123;dp[j], dp[j<span class="hljs-number">-1</span>], prev&#125;) + <span class="hljs-number">1</span>;<br>                    max_len = <span class="hljs-built_in">max</span>(max_len, dp[j]);<br>                &#125; <span class="hljs-keyword">else</span><br>                    dp[j] = <span class="hljs-number">0</span>;<br>                prev = tmp; <span class="hljs-comment">// 更新 prev，變成下一輪的左上角</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len * max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：3ms - Beats 90.68%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 69. Sqrt(x) - 解題紀錄</title>
    <link href="/LeetCode-69-Sqrt-x-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-69-Sqrt-x-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/sqrtx">連結</a><br>難度：Easy</p><p>求根號 x 的整數部分<br>且不能使用內建的 function 或運算子</p><h2 id="解法1：暴力法"><a href="#解法1：暴力法" class="headerlink" title="解法1：暴力法"></a>解法1：暴力法</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(x + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i * i == x:<br>                <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">elif</span> i * i &gt; x:<br>                <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Runtime：1551ms - Beats 6.58%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>記得用 <code>long</code> 避免 overflow</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((<span class="hljs-type">long</span>)i * i &lt;= x)<br>            i++;<br>        <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：8ms - Beats 14.25%</p><h2 id="解法2：二分搜-binary-search"><a href="#解法2：二分搜-binary-search" class="headerlink" title="解法2：二分搜 (binary search)"></a>解法2：二分搜 (binary search)</h2><p>實際跑跑看步驟就能知道<br>如果用我的寫法，最後位置會落在 <code>right</code></p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, x<br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            square = mid * mid<br>            <span class="hljs-keyword">if</span> square &gt; x:<br>                right = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> square &lt; x:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = x;<br>        <span class="hljs-type">long</span> mid, square;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            square = mid * mid;<br>            <span class="hljs-keyword">if</span> (square &gt; x)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (square &lt; x)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法3：牛頓法"><a href="#解法3：牛頓法" class="headerlink" title="解法3：牛頓法"></a>解法3：牛頓法</h2><p>使用<a href="https://www.youtube.com/watch?v=Quw4ZHLH2CY">牛頓求根法</a><br>求根號 x 可轉為求 $f(r) &#x3D; r^2 - x &#x3D; 0$ 的實數解<br>就能套用牛頓法<br>牛頓法的迭代公式</p><div style="font-size: 1.5em">$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$<br></div><p><br>$f(r)$ 的一次微分 $f’(r) &#x3D; 2r$</p><div style="font-size: 1.5em">$r - \frac{f(r)}{f'(r)} = r - \frac{r^2 - x}{2r} = r - (r - \frac{x}{r}) / 2$</div><p><br>這就是最後會在迴圈裡迭代的式子<br>由於這題是取整數部分<br>因此除法的部分也要改成取整數，避免無窮迴圈</p><h3 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        r = x<br>        <span class="hljs-keyword">while</span> r * r &gt; x:<br>            r = (r + x / r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(r)<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> r = x;<br>        <span class="hljs-keyword">while</span> (r * r &gt; x)<br>            r = (r + x / r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://darktiantian.github.io/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math/">LeetCode算法题整理（数学篇）Math</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Math</tag>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 35. Search Insert Position - 解題紀錄</title>
    <link href="/LeetCode-35-Search-Insert-Position-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-35-Search-Insert-Position-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/search-insert-position">連結</a><br>難度：Easy</p><p>給定一個已經由小到大排序好的 array 和 target<br>如果 target 有在裡面的話，回傳它的 index<br>如果沒有，回傳它應該要被插入的 index<br>並且時間複雜度要 O(log n)</p><h2 id="解法：二分搜-binary-search"><a href="#解法：二分搜-binary-search" class="headerlink" title="解法：二分搜 (binary search)"></a>解法：二分搜 (binary search)</h2><p>實際跑跑看步驟就會知道最後的位置落在哪裡<br>如果是用我的寫法，就會是 <code>left</code></p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] == target:<br>                <span class="hljs-keyword">return</span> mid<br>            <span class="hljs-keyword">elif</span> nums[mid] &gt; target:<br>                right = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Array</tag>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 63. Unique Paths II - 解題紀錄</title>
    <link href="/LeetCode-63-Unique-Paths-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-63-Unique-Paths-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/unique-paths-ii">連結</a><br>難度：Medium</p><p>承<a href="https://leetcode.com/problems/unique-paths">上一題</a><br>多了障礙物，矩陣裡的值如果是 1 代表為障礙物，不能走</p><h2 id="解法：DP"><a href="#解法：DP" class="headerlink" title="解法：DP"></a>解法：DP</h2><h3 id="寫法1：二維-DP"><a href="#寫法1：二維-DP" class="headerlink" title="寫法1：二維 DP"></a>寫法1：二維 DP</h3><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        m, n = <span class="hljs-built_in">len</span>(obstacleGrid), <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>                dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">0</span>:<br>                    dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j]<br><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>                dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>)<br>                    dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-1</span>][j];<br><br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="寫法2：一維-DP"><a href="#寫法2：一維-DP" class="headerlink" title="寫法2：一維 DP"></a>寫法2：一維 DP</h3><p>將空間優化成一維<br>DP 方式和上一題相同 (<a href="https://citrus0610.github.io/LeetCode-62-Unique-Paths-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/">解題文章</a>)<br>多了判斷值為 1 的部份，以及 dp 的初始化不同</p><h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        m, n = <span class="hljs-built_in">len</span>(obstacleGrid), <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>        dp = [<span class="hljs-number">0</span>] * n<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>                dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span>:<br>                    dp[j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[j] += dp[j-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>                dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 62. Unique Paths - 解題紀錄</title>
    <link href="/LeetCode-62-Unique-Paths-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-62-Unique-Paths-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/unique-paths">連結</a></p><p>給定一個 m x n 的表格<br>從左上走到右下，只能往右或往下走<br>求方法數</p><h2 id="解法1：DP"><a href="#解法1：DP" class="headerlink" title="解法1：DP"></a>解法1：DP</h2><h3 id="寫法1：二維-DP"><a href="#寫法1：二維-DP" class="headerlink" title="寫法1：二維 DP"></a>寫法1：二維 DP</h3><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [[<span class="hljs-number">1</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="寫法2：一維-DP"><a href="#寫法2：一維-DP" class="headerlink" title="寫法2：一維 DP"></a>寫法2：一維 DP</h3><p>由於 <code>dp[i][j]</code> 只依賴於左邊和上面的格子<br>代表只需要保留上一個 row 的資訊來計算下一個 row<br>因此可將空間優化成一維</p><p><code>dp[j]</code> 表示走到當前 row 的第 j 個位置的方法數<br>一開始最上面那個 row 每一格只能往右走<br>每格只有一種走法，因此全部初始化為 1</p><p>一維 DP 的核心</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        dp[j] += dp[j-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><code>dp[j]</code> 還沒被改時，代表上面那格的結果<br><code>dp[j-1]</code> 代表左邊那格的結果<br>因此 <code>dp[j] = dp[j] + dp[j-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [<span class="hljs-number">1</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                dp[j] += dp[j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)</span></span><br><span class="hljs-function">            <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)</span></span><br><span class="hljs-function">                dp[j] +</span>= dp[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法2：排列組合"><a href="#解法2：排列組合" class="headerlink" title="解法2：排列組合"></a>解法2：排列組合</h2><p>使用高中數學的排列組合<br>題目所求可以看成從 (m-1)+(n-1) 個位置取 (m-1) 的組合數<br>這 (m-1) 個位置指定為向下走，其餘位置向右走<br>也就是</p><div style="font-size: 1.5em">$C^{(m-1)+(n-1)}_{(m-1)} = C^{(m+n-2)}_{(m-1)} = C^{(m+n-2)}_{(n-1)}$</div><p><br>取 (m-1) 或 (n-1) 都可以，選比較小的即可<br>接著代入公式</p><div style="font-size: 1.5em">$C^a_b = \frac{a!}{b!(a - b)!} = \frac{a \cdot (a-1) \cdot (a-2) \ldots (a-b+1)}{b \cdot (b-1) \cdot (b-2) \ldots 2 \cdot 1}$</div><p><br>使用 python 內建的 <code>factorial</code> 函數計算階乘</p><h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> factorial<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        a, b = m + n - <span class="hljs-number">2</span>, <span class="hljs-built_in">min</span>(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> factorial(a) // factorial(b) // factorial(a - b)<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><p>但其實用階乘算這個公式會多出不必要的計算<br>還能再優化</p><p>用迴圈迭代 i，從 1 到 b<br>a &#x2F; 1<br>a * (a-1) &#x2F; (1 * 2)<br>a * (a-1) * (a-2) &#x2F; (1 * 2 * 3)<br>…<br>a * (a-1) * (a-2) * (a-b+1) &#x2F; (1 * 2 * 3 * b)<br>且每一項必定能被 i 整除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        a, b = m + n - <span class="hljs-number">2</span>, <span class="hljs-built_in">min</span>(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>        comb = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, b + <span class="hljs-number">1</span>):<br>            comb = comb * (a - i + <span class="hljs-number">1</span>) // i<br>        <span class="hljs-keyword">return</span> comb<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><p>記得不能用 int，會 overflow</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> a = m + n - <span class="hljs-number">2</span>, b = <span class="hljs-built_in">min</span>(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> comb = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b; i++)<br>            comb = comb * (a - i + <span class="hljs-number">1</span>) / i;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)comb;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Math</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1137. N-th Tribonacci Number - 解題紀錄</title>
    <link href="/LeetCode-1137-N-th-Tribonacci-Number-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-1137-N-th-Tribonacci-Number-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/n-th-tribonacci-number">連結</a><br>難度：Easy</p><p>費氏數列的變形<br>後面一項是前面三項相加<br>求第 n 項</p><h2 id="解法：一維-DP"><a href="#解法：一維-DP" class="headerlink" title="解法：一維 DP"></a>解法：一維 DP</h2><p>跟<a href="https://citrus0610.github.io/LeetCode-509-Fibonacci-Number-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84">一般的費氏數列解法</a>相同</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tribonacci</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        t = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>            t.append(t[i-<span class="hljs-number">1</span>] + t[i-<span class="hljs-number">2</span>] + t[i-<span class="hljs-number">3</span>])<br>        <span class="hljs-keyword">return</span> t[n]<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><p>將空間複雜度優化為 O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tribonacci</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">elif</span> n == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br>        t0, t1, t2 = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>            t0, t1, t2 = t1, t2, t0 + t1 + t2<br>        <span class="hljs-keyword">return</span> t2<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tribonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> t0 = <span class="hljs-number">0</span>, t1 = <span class="hljs-number">1</span>, t2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> tmp0 = t0, tmp1 = t1;<br>            t0 = t1;<br>            t1 = t2;<br>            t2 = tmp0 + tmp1 + t2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://dwye.dev/post/python-fibonacci/">Python 費氏數列解法（一）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Math</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 509. Fibonacci Number - 解題紀錄</title>
    <link href="/LeetCode-509-Fibonacci-Number-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-509-Fibonacci-Number-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/fibonacci-number">連結</a><br>難度：Easy</p><p>求費氏數列的第 n 項</p><h2 id="解法：一維-DP"><a href="#解法：一維-DP" class="headerlink" title="解法：一維 DP"></a>解法：一維 DP</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        f = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            f.append(f[i-<span class="hljs-number">1</span>] + f[i-<span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">return</span> f[n]<br></code></pre></td></tr></table></figure><p>Runtime：24ms - Beats 99.19%</p><p>將空間複雜度優化為 O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> n<br><br>        f1, f2 = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            f1, f2 = f2, f1 + f2<br>        <span class="hljs-keyword">return</span> f2<br></code></pre></td></tr></table></figure><p>Runtime：31ms - Beats 93.70%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> f1 = <span class="hljs-number">0</span>, f2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> tmp = f2;<br>            f2 = f1 + f2;<br>            f1 = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://dwye.dev/post/python-fibonacci/">Python 費氏數列解法（一）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Math</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 70. Climbing Stairs - 解題紀錄</title>
    <link href="/LeetCode-70-Climbing-Stairs-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-70-Climbing-Stairs-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/climbing-stairs">連結</a><br>難度：Easy</p><p>爬樓梯每次能爬 1 階或 2 階<br>樓梯總共有 n 階<br>求爬到第 n 階的方法數</p><h2 id="解法：數列規律-DP"><a href="#解法：數列規律-DP" class="headerlink" title="解法：數列規律 + DP"></a>解法：數列規律 + DP</h2><p>由於每次只能爬 1 階或 2 階<br>所以如果要爬到第 n 階<br>必定只能從第 n-1 階爬 1 階<br>或是從第 n-2 階爬 2 階<br>設爬到第 n 階之方法數為 <code>f(n)</code><br>因此 <code>f(n) = f(n-1) + f(n-2)</code><br>接著用簡單的一維 DP 就能做完了</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        f = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>            f.append(f[i-<span class="hljs-number">1</span>] + f[i-<span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">return</span> f[n]<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><p>可將空間複雜度再優化為 O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> n<br><br>        f1, f2 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>            f1, f2 = f2, f1 + f2<br>        <span class="hljs-keyword">return</span> f2<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>這題 n 的測資最大只到 45<br>int 不會 overflow，直接用 int 即可<br>如果再大一點的話就要用 long 或 long long 了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> f1 = <span class="hljs-number">1</span>, f2 = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> tmp = f2;<br>            f2 = f1 + f2;<br>            f1 = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://dwye.dev/post/python-fibonacci/">Python 費氏數列解法（一）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Math</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 684. Redundant Connection - 解題紀錄</title>
    <link href="/LeetCode-684-Redundant-Connection-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-684-Redundant-Connection-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/redundant-connection">連結</a><br>難度：Medium</p><p>給定一個 graph<br>這個 graph 原本是個有 n 個 node 的 tree<br>從這個 tree 裡加上一條原本不是屬於這個 tree 的邊<br>就變成了題目給定的 graph<br>要你求出一條移除後會讓這個 graph 變回 tree 的邊<br>如果有多個答案，要回傳出現在 input 裡最後面的那條邊</p><h2 id="解法1：Union-Find"><a href="#解法1：Union-Find" class="headerlink" title="解法1：Union-Find"></a>解法1：Union-Find</h2><p>使用 Union-Find (Disjoint-Set)<br>依序將 input edge 的兩個頂點 union 起來<br>使它們變成屬於同一個 set<br>如果 union 時發現它們已經在同一個 set<br>代表加了這條邊後，會從 tree 變為 graph<br>這條邊就是題目要的答案</p><p>一開始要將每個 node 的 parent 初始化成自己<br>也就是<br>parent[1] &#x3D; 1<br>parent[2] &#x3D; 2<br>parent[3] &#x3D; 3<br>…<br>parent[n] &#x3D; n<br>可以直接使用 <code>list(range(n + 1))</code><br>就不需要用迴圈初始化了</p><p>時間複雜度：<code>O(n * α(n)) ≈ O(n)</code></p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRedundantConnection</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(edges)<br>        parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>))<br>        rank = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>):<br>            <span class="hljs-keyword">if</span> x != parent[x]:<br>                parent[x] = find(parent[x])<br>            <span class="hljs-keyword">return</span> parent[x]<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>):<br>            root_x = find(x)<br>            root_y = find(y)<br>            <span class="hljs-keyword">if</span> root_x == root_y:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> rank[root_x] &lt; rank[root_y]:<br>                parent[root_x] = root_y<br>            <span class="hljs-keyword">elif</span> rank[root_y] &lt; rank[root_x]:<br>                parent[root_y] = root_x<br>            <span class="hljs-keyword">else</span>:<br>                parent[root_x] = root_y<br>                rank[root_y] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-keyword">if</span> union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]):<br>                <span class="hljs-keyword">return</span> edge<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent, rank;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x])<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">union_set</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> root_x = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> root_y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (root_x == root_y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (rank[root_x] &lt; rank[root_y])<br>            parent[root_x] = root_y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[root_y] &lt; rank[root_x])<br>            parent[root_y] = root_x;<br>        <span class="hljs-keyword">else</span> &#123;<br>            parent[root_x] = root_y;<br>            rank[root_y]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>();<br>        parent.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>        rank.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>            parent[i] = i;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> u = edges[i][<span class="hljs-number">0</span>], v = edges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">union_set</span>(u, v))<br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;u, v&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法2：BFS"><a href="#解法2：BFS" class="headerlink" title="解法2：BFS"></a>解法2：BFS</h2><p>每次新增邊之前<br>先判斷邊上的兩個頂點是否已經在 graph 裡<br>如果是的話<br>接著檢查 graph 裡是否存在連接這兩個頂點的邊<br>如果有，代表這條邊就是答案</p><p>時間複雜度：最差 <code>O(n^2)</code></p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findRedundantConnection</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">start, target</span>):<br>            q = deque([start])<br>            visited = <span class="hljs-built_in">set</span>([start])<br>            <span class="hljs-keyword">while</span> q:<br>                node = q.popleft()<br>                <span class="hljs-keyword">if</span> node == target:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[node]:<br>                    <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                        visited.add(neighbor)<br>                        q.append(neighbor)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-keyword">if</span> graph[u] <span class="hljs-keyword">and</span> graph[v] <span class="hljs-keyword">and</span> bfs(u, v):<br>                <span class="hljs-keyword">return</span> [u, v]<br>            graph[u].append(v)<br>            graph[v].append(u)<br><br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>Runtime：3ms - Beats 54.48%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        set&lt;<span class="hljs-type">int</span>&gt; visited = &#123;start&#125;;<br>        q.<span class="hljs-built_in">push</span>(start);<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node == target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>                <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">find</span>(neighbor) == visited.<span class="hljs-built_in">end</span>()) &#123;<br>                    visited.<span class="hljs-built_in">insert</span>(neighbor);<br>                    q.<span class="hljs-built_in">push</span>(neighbor);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> u = edge[<span class="hljs-number">0</span>], v = edge[<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">find</span>(u) != graph.<span class="hljs-built_in">end</span>() &amp;&amp;<br>                graph.<span class="hljs-built_in">find</span>(v) != graph.<span class="hljs-built_in">end</span>() &amp;&amp;<br>                <span class="hljs-built_in">bfs</span>(u, v))<br>                <span class="hljs-keyword">return</span> &#123;u, v&#125;;<br><br>            graph[u].<span class="hljs-built_in">push_back</span>(v);<br>            graph[v].<span class="hljs-built_in">push_back</span>(u);<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：14ms - Beats 10.78%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://haogroot.com/2021/01/29/union_find-leetcode/">Union-Find &#x2F; Disjoint-Set – 陪你刷題</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>BFS</tag>
      
      <tag>Union Find</tag>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 130. Surrounded Regions - 解題紀錄</title>
    <link href="/LeetCode-130-Surrounded-Regions-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-130-Surrounded-Regions-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p><a href="https://leetcode.com/problems/surrounded-regions">連結</a><br>難度：Medium</p><p>給定一個 m x n 的矩陣，裡面會有 O 或 X<br>O 上下左右連起來形成的區域<br>若區域中沒有任何 O 是在邊緣<br>則要將該區域的所有 O 變成 X</p><p>並且只能 in-place 修改原矩陣<br>不能用額外的矩陣存</p><h2 id="解法1：BFS-暴力"><a href="#解法1：BFS-暴力" class="headerlink" title="解法1：BFS 暴力"></a>解法1：BFS 暴力</h2><p>一般的 BFS 即可<br>visited 的部份不使用 set，因為時間會是 O(log n)<br>用一個額外的二維矩陣即可<br>雖然需要額外的記憶體空間<br>但時間是 O(1)，會快很多</p><p>用一個 boolean 變數 <code>visited_edge</code> 去紀錄當前的 BFS 遍歷有沒有走到邊緣<br>以及用一個 <code>tmplist</code> 去存當前的 BFS 走過的所有格子<br>遍歷完當前的 BFS 後，若過程中已經有走過邊緣<br>則 <code>tmplist</code> 紀錄的所有格子要變為 X</p><p>另外，往上下左右走的部分<br>用一個 <code>directions</code> list 存 4 個方向<br>這樣就能用迴圈迭代，而不用寫重複又冗長的 if 區塊</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify board in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        visited = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        directions = [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visited[i][j]:<br>                    q = deque([(i, j)])<br>                    visited[i][j] = <span class="hljs-literal">True</span><br>                    tmplist = [(i, j)]<br>                    visited_edge = <span class="hljs-literal">False</span><br><br>                    <span class="hljs-keyword">while</span> q:<br>                        x, y = q.popleft()<br>                        <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> x == m - <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> y == n - <span class="hljs-number">1</span>:<br>                            visited_edge = <span class="hljs-literal">True</span><br><br>                        <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> directions:<br>                            row, col = x + dx, y + dy<br>                            <span class="hljs-keyword">if</span> (<br>                                <span class="hljs-number">0</span> &lt;= row &lt; m<br>                                <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= col &lt; n<br>                                <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visited[row][col]<br>                                <span class="hljs-keyword">and</span> board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span><br>                            ):<br>                                q.append((row, col))<br>                                visited[row][col] = <span class="hljs-literal">True</span><br>                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited_edge:<br>                                    tmplist.append((row, col))<br><br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited_edge:<br>                        <span class="hljs-keyword">for</span> row, col <span class="hljs-keyword">in</span> tmplist:<br>                            board[row][col] = <span class="hljs-string">&#x27;X&#x27;</span><br></code></pre></td></tr></table></figure><p>Runtime：15ms - Beats 19.80%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>(), n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; !visited[i][j]) &#123;<br>                    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>                    q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; tmplist = &#123;&#123;i, j&#125;&#125;;<br>                    <span class="hljs-type">bool</span> visited_edge = <span class="hljs-literal">false</span>;<br><br>                    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>                        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p = q.<span class="hljs-built_in">front</span>();<br>                        <span class="hljs-type">int</span> x = p.first, y = p.second;<br>                        q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || y == <span class="hljs-number">0</span> || x == m - <span class="hljs-number">1</span> || y == n - <span class="hljs-number">1</span>)<br>                            visited_edge = <span class="hljs-literal">true</span>;<br><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> dir : directions) &#123;<br>                            <span class="hljs-type">int</span> row = x + dir.first, col = y + dir.second;<br>                            <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp;<br>                                !visited[row][col] &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                                q.<span class="hljs-built_in">push</span>(&#123;row, col&#125;);<br>                                visited[row][col] = <span class="hljs-literal">true</span>;<br>                                tmplist.<span class="hljs-built_in">push_back</span>(&#123;row, col&#125;);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (!visited_edge)<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos : tmplist)<br>                            board[pos.first][pos.second] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：1ms - Beats 35.75%</p><h2 id="解法2：BFS-優化-從邊緣的-O-開始找"><a href="#解法2：BFS-優化-從邊緣的-O-開始找" class="headerlink" title="解法2：BFS 優化 - 從邊緣的 O 開始找"></a>解法2：BFS 優化 - 從邊緣的 O 開始找</h2><p>比起暴力 BFS，少了很多不必要的搜尋，時間快更多</p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify board in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        visited = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        directions = [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)]<br><br>        q = deque()<br>        <span class="hljs-comment"># 找邊緣為 O 的位置</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">if</span> board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                q.append((i, <span class="hljs-number">0</span>))<br>                visited[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">if</span> board[i][n-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                q.append((i, n - <span class="hljs-number">1</span>))<br>                visited[i][n-<span class="hljs-number">1</span>] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                q.append((<span class="hljs-number">0</span>, j))<br>                visited[<span class="hljs-number">0</span>][j] = <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">if</span> board[m-<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                q.append((m - <span class="hljs-number">1</span>, j))<br>                visited[m-<span class="hljs-number">1</span>][j] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 找與邊緣連通的 O</span><br>        <span class="hljs-keyword">while</span> q:<br>            x, y = q.popleft()<br>            <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> directions:<br>                row, col = x + dx, y + dy<br>                <span class="hljs-keyword">if</span> (<br>                    <span class="hljs-number">0</span> &lt;= row &lt; m<br>                    <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= col &lt; n<br>                    <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visited[row][col]<br>                    <span class="hljs-keyword">and</span> board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span><br>                ):<br>                    visited[row][col] = <span class="hljs-literal">True</span><br>                    q.append((row, col))<br><br>        <span class="hljs-comment"># 將與邊緣不連通的 O 改為 X</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visited[i][j]:<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>(), n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br><br>        <span class="hljs-comment">// 找邊緣為 O 的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">0</span>&#125;);<br>                visited[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[i][n<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;i, n - <span class="hljs-number">1</span>&#125;);<br>                visited[i][n<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, j&#125;);<br>                visited[<span class="hljs-number">0</span>][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[m<span class="hljs-number">-1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;m - <span class="hljs-number">1</span>, j&#125;);<br>                visited[m<span class="hljs-number">-1</span>][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找與邊緣連通的 O</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = p.first, y = p.second;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> dir : directions) &#123;<br>                <span class="hljs-type">int</span> dx = dir.first, dy = dir.second;<br>                <span class="hljs-type">int</span> row = x + dx, col = y + dy;<br><br>                <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp;<br>                    !visited[row][col] &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 將與邊緣不連通的 O 改為 X</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; !visited[i][j])<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>BFS</tag>
      
      <tag>Matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 80. Remove Duplicates from Sorted Array II - 解題紀錄</title>
    <link href="/LeetCode-80-Remove-Duplicates-from-Sorted-Array-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-80-Remove-Duplicates-from-Sorted-Array-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii">連結</a><br>難度：Medium</p><p>承<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array">上一題</a><br>給定一個已經由小到大排序的 array<br>要你移除重複的元素，使得每個元素最多出現 2 次<br>並且只能 in-place 修改原 array<br>不能用額外的記憶體空間存</p><p>最後只需要回傳 k<br>新的 array 不用回傳，只要修改原始的 array<br>k 代表修改後的 array 前 k 個元素符合題目要求<br>而第 k 個之後的元素不用管</p><h2 id="解法1：雙指標-index-從-1-開始"><a href="#解法1：雙指標-index-從-1-開始" class="headerlink" title="解法1：雙指標 (index 從 1 開始)"></a>解法1：雙指標 (index 從 1 開始)</h2><p>跟前一題差不多 (<a href="https://citrus0610.github.io/LeetCode-26-Remove-Duplicates-from-Sorted-Array-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/">解題文章</a>)<br>也是維護 index i 和 k<br>差別在於，要多判斷最多能連續兩個相同的值<br>原本是只有 <code>nums[i]</code> 和 <code>nums[i-1]</code> 不相等時才會覆寫值<br>現在要變成相等時也會覆寫值，但最多只連續 2 次<br>因此多一個 <code>cnt</code> 變數紀錄次數<br>當 <code>nums[i]</code> 和 <code>nums[i-1]</code> 不相等時，<code>cnt</code> 歸零重新計數</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> n<br><br>        k = <span class="hljs-number">1</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> nums[i] != nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span> k != i: <span class="hljs-comment"># 可不寫</span><br>                    nums[k] = nums[i]<br>                k += <span class="hljs-number">1</span><br>                cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">elif</span> nums[i] == nums[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> cnt &lt; <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> k != i: <span class="hljs-comment"># 可不寫</span><br>                    nums[k] = nums[i]<br>                k += <span class="hljs-number">1</span><br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> k<br></code></pre></td></tr></table></figure><p>Runtime：78ms - Beats 89.32%</p><p>寫法可以更精簡<br>把判斷覆寫和計數的部份獨立分開<br>就不用多寫一層重複的 if</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> n<br><br>        k = <span class="hljs-number">1</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            cnt = cnt + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> nums[i] == nums[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> cnt &lt; <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">if</span> k != i: <span class="hljs-comment"># 可不寫</span><br>                    nums[k] = nums[i]<br>                k += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> k<br></code></pre></td></tr></table></figure><p>Runtime：78ms - Beats 89.32%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>由於 <code>if (k != i)</code> 可不寫<br>寫法能更精簡，將 <code>k += 1</code> 寫成 <code>k++</code> 放進 index 裡<br>C++ 中多餘的賦值，代價是很低的，而 python 會比較高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            cnt = (nums[i] == nums[i<span class="hljs-number">-1</span>])? cnt + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (cnt &lt; <span class="hljs-number">2</span>)<br>                nums[k++] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：3ms - Beats 96.09%</p><h2 id="解法2：雙指標-index-從-2-開始"><a href="#解法2：雙指標-index-從-2-開始" class="headerlink" title="解法2：雙指標 (index 從 2 開始)"></a>解法2：雙指標 (index 從 2 開始)</h2><p>改成從 2 開始<br>並直接判斷位置 i 和 k-2 的值相不相同<br>就可確保最多只有連續 2 個相同值<br>是個比較神奇但更簡單的方法</p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> n<br><br>        k = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            <span class="hljs-keyword">if</span> nums[i] != nums[k-<span class="hljs-number">2</span>]:<br>                <span class="hljs-keyword">if</span> k != i: <span class="hljs-comment"># 可不寫</span><br>                    nums[k] = nums[i]<br>                k += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> k<br></code></pre></td></tr></table></figure><p>Runtime：68ms - Beats 99.16%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[k<span class="hljs-number">-2</span>])<br>                nums[k++] = nums[i];<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：3ms - Beats 96.09%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Two Pointers</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 26. Remove Duplicates from Sorted Array - 解題紀錄</title>
    <link href="/LeetCode-26-Remove-Duplicates-from-Sorted-Array-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-26-Remove-Duplicates-from-Sorted-Array-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array">連結</a><br>難度：Easy</p><p>給定一個已經由小到大排序的 array<br>要你移除重複的元素，使得每個元素只出現一次<br>並且只能 in-place 修改原 array<br>不能用額外的記憶體空間存</p><p>最後只需要回傳 k<br>新的 array 不用回傳，只要修改原始的 array<br>k 代表修改後的 array 前 k 個元素符合題目要求<br>而第 k 個之後的元素不用管</p><h2 id="解法：雙指標"><a href="#解法：雙指標" class="headerlink" title="解法：雙指標"></a>解法：雙指標</h2><p>維護 2 個 index<br>i：遍歷所有元素<br>k：要覆寫的位置<br>i 和 k 從 1 開始<br>當 <code>nums[i]</code> 與 <code>nums[i-1]</code> 不相等時<br>將 <code>nums[k]</code> 賦值為 <code>nums[i]</code>，並遞增 k<br>k 與 i 相同時，不需要賦值，這個可判斷可不判斷，不影響</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        k = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] != nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span> k != i: <span class="hljs-comment"># 可不寫</span><br>                    nums[k] = nums[i]<br>                k += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> k<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>由於 <code>if (k != i)</code> 可不判斷<br>寫法能更精簡，將 <code>k += 1</code> 寫成 <code>k++</code> 放進 index 裡<br>C++ 中多餘的賦值，代價是很低的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[i<span class="hljs-number">-1</span>])<br>                nums[k++] = nums[i];<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Two Pointers</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 82. Remove Duplicates from Sorted List II - 解題紀錄</title>
    <link href="/LeetCode-82-Remove-Duplicates-from-Sorted-List-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-82-Remove-Duplicates-from-Sorted-List-II-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii">連結</a><br>難度：Medium</p><p>承<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list">上一題</a><br>給定一個已排序好的 linked list<br>除了移除重複的 node 以外，還要移除 node 本身<br>也就是移除所有含有重複值的 node，只留下沒有重複的 node</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>遍歷 node 時，若遇到當前 node 的值與下一個 node 相同<br>則一直往後走，直到 node 的值與下一個 node 不同<br>這部份用一個第二層的 while 迴圈即可<br>接著判斷 pre_node 需不需要往後接</p><p>然後會發現如果一開始 head 是重複值的話就會錯<br>因此 pre_node 需要用一個 dummy<br>並將 dummy 的 next 初始化為 head<br>遍歷 node 時，從 dummy.next 開始走<br>而最後回傳的 head 則變為 dummy.next</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-built_in">next</span>=head)<br>        pre_node = dummy<br>        node = dummy.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> node:<br>            <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> node.val == node.<span class="hljs-built_in">next</span>.val:<br>                node = node.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> pre_node.<span class="hljs-built_in">next</span> != node:<br>                pre_node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                pre_node = node<br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* pre_node = dummy;<br>        ListNode* node = head;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-keyword">while</span> (node-&gt;next &amp;&amp; node-&gt;val == node-&gt;next-&gt;val)<br>                node = node-&gt;next;<br>            <span class="hljs-keyword">if</span> (pre_node-&gt;next != node)<br>                pre_node-&gt;next = node-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                pre_node = node;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://shannonhung.github.io/posts/leetcode-82-remove-duplicates-from-sorted-list-ll/">LeetCode #82 Remove Duplicates From Sorted List II - 刷題之旅</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Linked-List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 83. Remove Duplicates from Sorted List - 解題紀錄</title>
    <link href="/LeetCode-83-Remove-Duplicates-from-Sorted-List-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/"/>
    <url>/LeetCode-83-Remove-Duplicates-from-Sorted-List-%E8%A7%A3%E9%A1%8C%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list">連結</a><br>難度：Easy</p><p>給定一個已排序好的 linked list<br>要你移除重複的 node，使得每個值只出現一次</p><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>遍歷 node，若當前 node 的值與前一個 node 的值相同<br>將前一個 node 的 next 指向當前 node 的下一個 node</p><p>需要注意的是，pre_node 的值必須初始化為特殊值<br>不能只有 <code>pre_node = ListNode()</code>，初始值會是 0<br>題目給定的 node 的值有可能為 0，這樣會錯</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        node = head<br>        pre_node = ListNode(<span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">while</span> node:<br>            <span class="hljs-keyword">if</span> node.val == pre_node.val:<br>                pre_node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                pre_node = node<br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* node = head;<br>        ListNode* pre_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(INT_MIN);<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;val == pre_node-&gt;val)<br>                pre_node-&gt;next = node-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                pre_node = node;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>遍歷 node，若當前 node 的值與下一個 node 的值相同<br>將當前 node 的 next 指向下下一個 node<br>比解法1簡單，不需要紀錄 pre_node</p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        node = head<br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> node.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">if</span> node.val == node.<span class="hljs-built_in">next</span>.val:<br>                node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* node = head;<br>        <span class="hljs-keyword">while</span> (node &amp;&amp; node-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;val == node-&gt;next-&gt;val)<br>                node-&gt;next = node-&gt;next-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Runtime：0ms - Beats 100.00%</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python</tag>
      
      <tag>C++</tag>
      
      <tag>Linked-List</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
